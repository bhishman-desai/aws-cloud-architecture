AWSTemplateFormatVersion: '2010-09-09'
Description: >
  CloudFormation template for setting up an EC2 instance for the app tier, running an Ubuntu AMI with necessary configurations.
  Follows 6 pillars of well architected framework along with their best practices.

Parameters:
  NamingPrefix:
    Type: String
    Default: term-end-app
    Description: Prefix for naming AWS resources

  LabRole:
    Description: Existing IAM role name
    Type: String
    Default: LabRole

  RoleArn:
    Description: Existing IAM role ARN
    Type: String
    Default: arn:aws:iam::114580182108:role/LabRole

  AMI:
    Description: AMI ID
    Type: String
    Default: ami-04b70fa74e45c3917

Resources:
  # EC2 Key Pair
  KeyPair:
    Type: AWS::EC2::KeyPair
    Properties:
      KeyName: !Ref NamingPrefix

  # Profile
  AppProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref LabRole

  # EC2 Instance
  AppTierInstance:
    Type: AWS::EC2::Instance
    Properties:
      InstanceType: t3.micro
      ImageId: !Ref AMI
      KeyName: !Ref NamingPrefix
      SubnetId: !ImportValue core-infrastructure-PrivateAppSubnet1Id
      SecurityGroupIds:
        - !ImportValue core-infrastructure-PrivateInstanceSGId
      IamInstanceProfile: !Ref AppProfile
      Tags:
        - Key: Name
          Value: !Sub '${NamingPrefix}-app-tier-instance'
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          sudo -s
          exec > >(tee /var/log/user-data.log|logger -t user-data -s 2>/dev/console) 2>&1
          
          # Update packages
          apt-get update -y

          # Install MySQL server
          apt-get install mysql-server -y

          # Install jq for JSON parsing
          apt-get install jq -y

          # Install AWS CLI
          snap install aws-cli --classic

          # Fetch database credentials from AWS Secrets Manager
          DB_SECRET=$(aws secretsmanager get-secret-value --secret-id db-credentials --query 'SecretString' --output text)
          DB_HOST=$(echo $DB_SECRET | jq -r '.host')
          DB_USER=$(echo $DB_SECRET | jq -r '.username')
          DB_PASSWORD=$(echo $DB_SECRET | jq -r '.password')

          # Create the database using MySQL CLI
          mysql -u $DB_USER -p$DB_PASSWORD -h $DB_HOST -e "create database waiting_coder;"

          # Install NVM (Node Version Manager)
          curl https://raw.githubusercontent.com/creationix/nvm/master/install.sh | bash
          export NVM_DIR="$HOME/.nvm"
          [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh" 

          # Install a compatible version of Node.js and set it as the default
          nvm install 20
          nvm use 20

          # Install PM2 (Daemon Process Manager)
          npm install -g pm2

          # Install AWS SDK for javascript (used to fetch credentials of db from secret manager)
          npm install -g @aws-sdk/client-secrets-manager

          # Clone the backend repository
          git clone https://github.com/bhishman-desai/waiting_coder.git
          cd waiting_coder
          
          # Populate database with tables and data
          mysql -u $DB_USER -p$DB_PASSWORD -h $DB_HOST -e "use waiting_coder; source waiting_coder.sql;"

          # Install backend dependencies
          cd backend
          npm install

          # Start the Node.js application using PM2
          pm2 start npm --name "waiting_coder" -- run dev

          # Ensure PM2 starts on reboot and saves the current list of processes
          pm2 startup
          pm2 save

  # Lambda Function to create AMI
  CreateAmiFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Role: !Ref RoleArn
      Runtime: nodejs16.x
      Timeout: 300
      VpcConfig:
        SubnetIds:
          - !ImportValue core-infrastructure-PrivateAppSubnet1Id
        SecurityGroupIds:
          - !ImportValue core-infrastructure-PrivateInstanceSGId
      Environment:
        Variables:
          IMAGE_NAME: !Sub '${NamingPrefix}-app-tier-image'
          DESCRIPTION: 'App tier AMI with Node.js application and MySQL configurations'
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const ec2 = new AWS.EC2();
          
          exports.handler = async function(event, context) {
              console.log("Event: ", JSON.stringify(event, null, 2));
              const instanceId = event.ResourceProperties.InstanceId || event.detail['instance-id'];
              const imageName = process.env.IMAGE_NAME;
              const description = process.env.DESCRIPTION;

              if (!instanceId) {
                  const errorMessage = "Instance ID is undefined in the event.";
                  console.error(errorMessage);
                  return {
                      StatusCode: 500,
                      Body: {Error: errorMessage}
                  };
              }

              console.log("Creating AMI for Instance ID: ", instanceId);
              const params = {
                  InstanceId: instanceId,
                  Name: imageName,
                  Description: description,
                  NoReboot: true
              };
              try {
                  const result = await ec2.createImage(params).promise();
                  console.log("AMI created: ", result.ImageId);
                  return {
                      StatusCode: 200,
                      Body: { ImageId: result.ImageId }
                  };
              } catch (error) {
                  console.error("Error creating AMI: ", error);
                  return {
                      StatusCode: 500,
                      Body: {Error: error.message}
                  };
              }
          };

  # Wrapper Lambda Function
  WrappingLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Role: !Ref RoleArn
      Runtime: nodejs16.x
      Timeout: 300
      VpcConfig:
        SubnetIds:
          - !ImportValue core-infrastructure-PrivateAppSubnet1Id
        SecurityGroupIds:
          - !ImportValue core-infrastructure-PrivateInstanceSGId
      Environment:
        Variables:
          AMI_LAMBDA_ARN: !GetAtt CreateAmiFunction.Arn
      Code:
        S3Bucket: term-end
        S3Key: wrapping-lambda.zip

  # Custom Resource to capture the AMI ID from the Wrapper Lambda Function
  CreateAmiCustomResource:
    Type: Custom::CreateAmi
    Properties:
      ServiceToken: !GetAtt WrappingLambdaFunction.Arn
      ServiceTimeout: 300
      LambdaFunctionName: !Ref CreateAmiFunction
      InstanceId: !Ref AppTierInstance

  # Create a Launch Template from the AMI
  AppLaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Properties:
      LaunchTemplateName: !Sub '${NamingPrefix}-app-tier-launch-template'
      LaunchTemplateData:
        ImageId: !GetAtt CreateAmiCustomResource.ImageId
        InstanceType: t3.micro
        SecurityGroupIds:
          - !ImportValue core-infrastructure-PrivateInstanceSGId
        IamInstanceProfile:
          Name: !Ref AppProfile

Outputs:
  InstanceId:
    Description: The Instance ID of the app tier
    Value: !Ref AppTierInstance
    Export:
      Name: !Sub '${AWS::StackName}-AppTierInstanceId'

  ImageId:
    Description: The AMI ID of the app tier
    Value: !GetAtt CreateAmiCustomResource.ImageId
    Export:
      Name: !Sub '${AWS::StackName}-AppTierImageId'

  LaunchTemplateId:
    Description: The Launch Template ID of the app tier
    Value: !Ref AppLaunchTemplate
    Export:
      Name: !Sub '${AWS::StackName}-AppLaunchTemplateId'

  WrapperLambdaFunctionOutput:
    Description: Wrapper Lambda Function Output
    Value: !GetAtt CreateAmiCustomResource.Response
    Export:
      Name: !Sub '${AWS::StackName}-WrapperLambdaFunctionOutput'

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "App Tier Configuration"
        Parameters:
          - LabRole
          - RoleArn
          - AMI
    ParameterLabels:
      LabRole:
        default: "Name of the role"
      RoleArn:
        default: "IAM Role ARN"
      AMI:
        default: "AMI ID"
